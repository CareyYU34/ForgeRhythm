<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <title>MediaPipe 動作驗證</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    />
  </head>

  <body>
    <!-- 頂部工具列：左邊鏡頭按鈕、右邊YT輸入（你要貼右就交給CSS） -->
    <div class="topbar">
      <button id="toggle" class="topbar-btn">開啟鏡頭</button>

      <div class="yt-input-row">
        <input id="ytUrl" class="yt-url" placeholder="youtube 連結輸入" />
        <button id="ytLoadBtn" class="yt-load-btn">載入</button>
      </div>
    </div>

    <!-- 主內容：中央 webcam + 右側 YouTube（預設隱藏，輸入後才顯示） -->
    <div class="layout">
      <div class="stage">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output"></canvas>
      </div>

      <div id="ytPanel" class="player-card is-hidden">
        <div class="video-wrapper">
          <div class="player" id="player"></div>

          <div class="overlay-play" id="overlayPlay">
            <i class="fas fa-play"></i>
          </div>

          <div class="controls-bar">
            <button id="playPauseBtn" class="btn">
              <i class="fas fa-play"></i>
            </button>

            <div class="volume-container">
              <button id="muteBtn" class="btn">
                <i class="fas fa-volume-high"></i>
              </button>
              <input
                type="range"
                id="volumeSlider"
                min="0"
                max="100"
                value="100"
                class="slider volume"
              />
            </div>

            <select id="playbackSpeed" class="control-select">
              <option value="0.5">0.5x</option>
              <option value="0.75">0.75x</option>
              <option value="1" selected>1x</option>
              <option value="1.25">1.25x</option>
              <option value="1.5">1.5x</option>
              <option value="2">2x</option>
            </select>

            <span class="time">
              <span id="currentTime">0:00</span> /
              <span id="duration">0:00</span>
            </span>

            <div class="seek-container">
              <input
                type="range"
                id="seekBar"
                min="0"
                max="100"
                value="0"
                class="slider seek"
              />
            </div>

            <button id="fullscreenBtn" class="fullscreen-btn">
              <i class="fas fa-expand"></i>
            </button>
          </div>
        </div>
      </div>
    </div>

    <script src="./youtube.js"></script>
    <script src="./math.js"></script>
    <script src="./https://www.youtube.com/iframe_api"></script>

    <script type="module">
      import {
        PoseLandmarker,
        FilesetResolver,
        DrawingUtils,
      } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.11";

      const video = document.getElementById("webcam");
      const canvas = document.getElementById("output");
      const canvasCtx = canvas.getContext("2d");
      const drawingUtils = new DrawingUtils(canvasCtx);
      const button = document.getElementById("toggle");

      let poseLandmarker = null;
      let running = false;
      let runningMode = "IMAGE";
      let stream = null;
      let lastVideoTime = -1;
      let rafId = null;
      let preMs = 0;
      let leftThighCordon = null;
      let rightThighCordon = null;
      let leftHandSpeed = 0;
      let rightHandSpeed = 0;
      let prevLeftP = null;
      let prevRightP = null;
      let prevRightPF = null;
      let prevLeftPF = null;
      let lastLeftHitMs = -Infinity;
      let lastRightHitMs = -Infinity;

      async function createPoseLandmarker() {
        const fileset = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.11/wasm",
        );

        poseLandmarker = await PoseLandmarker.createFromOptions(fileset, {
          baseOptions: {
            modelAssetPath: "../Model/pose_landmarker_full.task",
            delegate: "GPU",
          },
          runningMode,
          numPoses: 1,
          minPoseDetectionConfidence: 0.5,
          minPosePresenceConfidence: 0.5,
          minTrackingConfidence: 0.5,
          outputSegmentationMasks: false,
        });
      }
      createPoseLandmarker();

      async function startWebcam() {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: "user",
            width: { ideal: 720 },
            height: { ideal: 1280 },
            aspectRatio: 9 / 16,
          },
          audio: false,
        });
        video.srcObject = stream;
        console.log("Webcam started");
        video.addEventListener("loadeddata", predictWebcam);
        video.addEventListener("loadedmetadata", () => {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
        });
        await initHitSound("38_Standard Snare 1_v1.wav");
      }

      function stopWebcam() {
        if (rafId) cancelAnimationFrame(rafId);
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
          stream = null;
        }
        video.srcObject = null;
        lastVideoTime = -1;
        preMs = 0;
        prevLeftP = null;
        prevRightP = null;
        prevRightPF = null;
        prevLeftPF = null;
        lastLeftHitMs = -Infinity;
        lastRightHitMs = -Infinity;
        console.log("Webcam stopped");
      }

      function drawPose(x) {
        const THREE_POINT_CONNECTIONS = [
          // { start: 0, end: 1 }, //hip -> index
          // { start: 1, end: 2 }, //index -> knee
          { start: 0, end: 2 }, //hip -> knee
        ];
        drawingUtils.drawLandmarks(x, { color: "red", radius: 15 });
        drawingUtils.drawConnectors(x, THREE_POINT_CONNECTIONS);
      }

      //音效初始化
      let audioCtx = null;
      let hitBuffer = null;

      async function initHitSound(url) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const res = await fetch(url);
        const arrayBuffer = await res.arrayBuffer();
        hitBuffer = await audioCtx.decodeAudioData(arrayBuffer);
      }

      //觸發時呼叫
      function playHitWav() {
        if (!audioCtx || !hitBuffer) return;

        if (audioCtx.state === "suspended") {
          audioCtx.resume().catch(() => {});
        }

        const src = audioCtx.createBufferSource();
        src.buffer = hitBuffer;
        src.connect(audioCtx.destination);
        src.start(0);
      }
      async function predictWebcam() {
        if (runningMode !== "VIDEO") {
          runningMode = "VIDEO";
          await poseLandmarker.setOptions({ runningMode: "VIDEO" });
        }

        const webTimeMs = performance.now();

        if (video.currentTime !== lastVideoTime) {
          lastVideoTime = video.currentTime;
          poseLandmarker.detectForVideo(video, webTimeMs, (result) => {
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
            if (result.landmarks.length > 0) {
              const pickedLeftHand = [
                result.landmarks[0][23],
                result.landmarks[0][19],
                result.landmarks[0][25],
              ]; //hip, index, knee
              const pickedRightHand = [
                result.landmarks[0][24],
                result.landmarks[0][20],
                result.landmarks[0][26],
              ]; //hip, index, knee

              drawPose(pickedLeftHand);
              drawPose(pickedRightHand);
              console.log(pickedRightHand);
              //計算大腿線距離
              leftThighCordon = thighLineDistance(pickedLeftHand);
              rightThighCordon = thighLineDistance(pickedRightHand);

              if (leftThighCordon.T <= 0 || leftThighCordon.T >= 1) {
                leftThighCordon = changePT(leftThighCordon, pickedLeftHand);
              }
              if (rightThighCordon.T <= 0 || rightThighCordon.T >= 1) {
                rightThighCordon = changePT(rightThighCordon, pickedRightHand);
              }

              //計算手部速度
              const dt = (webTimeMs - preMs) / 1000;
              if (dt > 0 && prevLeftP && prevRightP) {
                leftHandSpeed = detectHandSpeed(
                  result.landmarks[0][19],
                  prevLeftP,
                  dt,
                );
                rightHandSpeed = detectHandSpeed(
                  result.landmarks[0][20],
                  prevRightP,
                  dt,
                );
                // console.log("Right Hand Speed:", rightHandSpeed);
                // console.log("Right thigh line distance:", rightThighCordon);
                // console.log("==========================");
              }

              prevLeftP = result.landmarks[0][19];
              prevRightP = result.landmarks[0][20];
              preMs = webTimeMs;

              //監控觸發條件
              const SPEED_HIT = 0.12; //命中速度
              const SPEED_MAX = 3.0; //追蹤跳點尖峰濾掉
              const PF_WARN = 0.5; //警戒區
              const PF_HIT = 0.3; //命中區
              const COOLDOWN_MS = 90; // 避免一次打擊連發

              const rightTrigger = monitoringTriggerConditions(
                prevRightPF,
                rightThighCordon,
                rightHandSpeed,
                SPEED_HIT,
                SPEED_MAX,
                PF_WARN,
                PF_HIT,
                webTimeMs,
                lastRightHitMs,
                COOLDOWN_MS,
              );
              const leftTrigger = monitoringTriggerConditions(
                prevLeftPF,
                leftThighCordon,
                leftHandSpeed,
                SPEED_HIT,
                SPEED_MAX,
                PF_WARN,
                PF_HIT,
                webTimeMs,
                lastLeftHitMs,
                COOLDOWN_MS,
              );

              prevRightPF = rightTrigger.prevPF;
              lastRightHitMs = rightTrigger.lastHitMs;
              prevLeftPF = leftTrigger.prevPF;
              lastLeftHitMs = leftTrigger.lastHitMs;

              if (leftTrigger.didHit || rightTrigger.didHit) {
                playHitWav();
              }
            }
          });
        }
        rafId = requestAnimationFrame(predictWebcam);
      }

      button.onclick = async () => {
        if (!poseLandmarker) return;
        running = !running;
        button.textContent = running ? "關閉鏡頭" : "開啟鏡頭";

        if (running) {
          await startWebcam();
        } else {
          stopWebcam();
        }
      };
    </script>
  </body>
</html>
